/*
 * The test runners in this file should be executed independant of one another (in other words, 
 * only one runner should be un-commented at any given time) in order to ensure that data produced
 * and/or modified by one does not affect the execution of any other.
 */



/**
* Inserts a backslash in front of each backslash in a String; this allows the original 
* backslashes in the String to be preserved through interpretation by a Javascript engine
* as source code or a part of source code. 

* @param str	a String
* @return		a version of {@code str} in which all backslashes are escaped
*/
function escapeBackslashes(str)
{
	return str.replace("\\", "\\\\");
}



/**
* Executes a storage operation on an indexedDB database.

* @param optionsObj				an object containing properties which identify an IDBDatabase
* @param databaseOpenRequestHandlerFunc		a function associated with the to-be-conducted storage operation
                                                capable of utilizing the IDBRequest generated by the
                                                act of opening the database specified in {@code optionsObj}
* @param accessErrorCompleteFunc		a function to execute in the event that the database 
                                                specified in {@code optionsObj} cannot be opened
*/
function indexedDB_executeStorageOperation(optionsObj, databaseOpenRequestHandlerFunc, accessErrorCompleteFunc)
{
    var indexedDB = (window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB);

    if(indexedDB)
    {
        var openDatabaseRequest = indexedDB.open(optionsObj.databaseName, optionsObj.databaseVersion);
        databaseOpenRequestHandlerFunc(openDatabaseRequest);
    }
    else
        accessErrorCompleteFunc();
}



/**
* Progresses the execution of the set of operations a given 
* storage operation belongs to in the event of its failure.

* @param complete                   a function capable of progressing the execution of the set
*                                   of related storage operations a given storage operation belongs to
* @param completeFuncArgArray       the prospective argument-array for {@code complete} 
*/
function createErrorCompleteFunction(complete, completeFuncArgArray)
{
	return function (error){ if(error) completeFuncArgArray.push(error); complete.apply(complete, completeFuncArgArray); };
}
	
	
/**
* Assigns functions to handle the various events that may fire during
* the handling of a request to open a database for a set operation.

* @param openDatabaseRequest    an IDBOpenDBRequest 
*/
function handleOpenDatabaseRequestExt(openDatabaseRequest, optionsObj, successFunc, accessErrorComplete)
{
    //Creates database structures using configuration data specified in optionsObj, provided the open() call
    //which spawned openDatabaseRequest was called with a database version higher than the current one. This is fired before openDatabaseRequest
    openDatabaseRequest.onupgradeneeded = function(){

        //Get a handle to the requested database and use it to create the 
        //object store specified by the pertinent properties in optionsObj
        var database = openDatabaseRequest.result;
        var targetObjectStore = database.createObjectStore(optionsObj.objectStoreData.name, optionsObj.objectStoreData);
        /////

        //Store the array of objects each containing configuration data for a 
        //prospective index of targetObjectStore in a local variable for easier access
        var objectStoreIndexDataArray = optionsObj.objectStoreIndexDataArray;

        //Loop through the objects in objectStoreIndexDataArray, using the
        //data contained in each to create an index for targetObjectStore
        var indexCount = objectStoreIndexDataArray.length;
        for(var i = 0; i < indexCount; i++)
        {
                var currentIndexDataObj = objectStoreIndexDataArray[i];
                targetObjectStore.createIndex(currentIndexDataObj.name, currentIndexDataObj.keyPath, currentIndexDataObj);
        }
        /////
    }
    /////

    //Delegates control flow to set() using openDatabaseRequest's result: the specified database
    openDatabaseRequest.onsuccess = function(){ successFunc(openDatabaseRequest.result); }

    //Progresses the execution of the set of operations the parent operation
    //belongs to in the event the desired database cannot be accessed
    openDatabaseRequest.onerror = accessErrorComplete;
}
	
	
	
/**
* Performs an indexedDB set operation on a specified object store in a
* specified database using data contained in a collection of objects.

* @param dataArray	an Array of Objects each specifying a value to be persisted and (optionally) a key which will map it in the store
* @param optionsObj     an object containing auxiliary data pertinent to the to-be-conducted operation
* @param complete	a function capable of progressing the execution of the set of related storage operations this operation belongs to
*/
function indexedDB_set(dataArray, optionsObj, complete)
{
    var i = 0;
    var dataCount = dataArray.length;
    
    //Will be used to help determine whether the databse connection created by this operation should be 
    //closed after its conclusion (a value of true indicates that the onversionchange event has been
    //fired, which prevents subsequent version changing connections to the database from being made)
    var wasUpgradeNeeded = false;     
    
    //Create a function that will be used to advance the set of operations  
    //that this operation belongs to in the event of its failure
    var errorComplete = createErrorCompleteFunction(complete, [0]);

   /**
    * Assigns functions to handle the various events that may fire during
    * the handling of a request to open a database for a set operation.

    * @param openDatabaseRequest        an IDBOpenDBRequest 
    */
    function handleOpenDatabaseRequest(openDatabaseRequest)
    {
        //Creates database structures using configuration data specified in optionsObj, provided the open() call
        //which spawned openDatabaseRequest was called with a database version higher than the current one. This is triggered before onsuccess()
        openDatabaseRequest.onupgradeneeded = function(){

            //Get a handle to the requested database and use it to create the 
            //object store specified by the pertinent properties in optionsObj
            var database = openDatabaseRequest.result;
            var targetObjectStore = database.createObjectStore(optionsObj.objectStoreData.name, optionsObj.objectStoreData);
            /////

            //Store the array of objects each containing configuration data for a 
            //prospective index of targetObjectStore in a local variable for easier access
            var objectStoreIndexDataArray = optionsObj.objectStoreIndexDataArray;

            //Loop through the objects in objectStoreIndexDataArray, using the
            //data contained in each to create an index for targetObjectStore
            var indexCount = objectStoreIndexDataArray.length;
            for(var i = 0; i < indexCount; i++)
            {
                var currentIndexDataObj = objectStoreIndexDataArray[i];
                targetObjectStore.createIndex(currentIndexDataObj.name, currentIndexDataObj.keyPath, currentIndexDataObj);
            }
            /////
            
            wasUpgradeNeeded = true;
        }
        /////

        //Delegates control flow to set() using openDatabaseRequest's result: the specified database
        openDatabaseRequest.onsuccess = function(){ set(openDatabaseRequest.result); }

        //Progresses the execution of the set of operations the parent operation
        //belongs to in the event the desired database cannot be accessed
        openDatabaseRequest.onerror = openDatabaseRequest.onblocked = errorComplete;
    }

   /**
    * Performs a set operation  using the data contained in the members objects
    * of {@code dataArray} on the object store specified in {@code optionsObj}.

    * @param database       the IDBDatabase object containing the object store that this operation will target
    */
    function set(database)
    {
        //Create the transaction that the set operation is to take place in
        var setTransaction = database.transaction([optionsObj.objectStoreData.name], "readwrite");
        setTransaction.onerror = errorComplete;

        //Get a handle to the target object store
        var targetObjectStore = setTransaction.objectStore(optionsObj.objectStoreData.name);

        //Store the presence of a key path in a local variable for use in determining how the data in dataArray will be stored
        var hasKeyPath = (targetObjectStore.keyPath !== null);

       /**
        * Advances the set operation.
        */
        function advance()
        {
            if(++i >= dataCount)
            {
                if(wasUpgradeNeeded || optionsObj.closeConnection)
                    database.close();
                complete(i);
            }
            else
                setDataItem();		//process the data item at i (which was just incremented in the 'if' clause)   		
        }

       /**
        * Inserts data derived from an object in {@code dataArray} in to {@code targetObjectStore}.
        */
        function setDataItem()
        {
            //Create the argument array for the set ("put") operation based on the presence of a key path for targetObjectStore
            var argArray = (hasKeyPath ? [dataArray[i].value] : [dataArray[i].value, dataArray[i].key]);

            //Create a request to insert the data contained in argArray in to targetObjectStore,
            //and specify advance() as the function to call upon success of the sub-operation
            var setRequest = targetObjectStore.put.apply(targetObjectStore, argArray); 
            setRequest.onsuccess = advance; 
            /////
        }

        setDataItem();	//starts the operation
    }

    indexedDB_executeStorageOperation(optionsObj, handleOpenDatabaseRequest, errorComplete);
}
	
	
	
/**
* Performs an indexedDB get or remove operation on items in a specified object store/database
* combo that are in a specified database that are keyed by Strings in a given collection.

* @param operationType      a String denoting the desired type of operation
* @param dataArray          an Array of Strings each denoting the key of tuple in the target table
* @param optionsObj         an object containing auxiliary data pertinent to the to-be-conducted operation
* @param complete           a function capable of progressing the execution of the set of related storage operations this operation belongs to
* @param useIndex           an optional parameter denoting whether the to-be-carried out operation
                            should be conducted using an index of the specified object store
*/
function indexedDB_getOrRemove(operationType, dataArray, optionsObj, complete, useIndex)
{
    var isGet = (operationType === "get");      
    var keyValuePairsObj = (isGet ? {} : undefined);            
    
    var i = 0;
    var dataCount = dataArray.length;

    //Create a function that will be used to advance the set of operations that 
    //this operation belongs to in the event of its failure
    var errorComplete = (isGet ? createErrorCompleteFunction(complete, [0, {}])
                               : createErrorCompleteFunction(complete, [0]));

   /**
    * Assigns functions to handle the various events that may fire during the
    * handling of a request to open a database for a get or remove operation.

    * @param openDatabaseRequest		an IDBOpenDBRequest 
    */
    function handleOpenDatabaseRequest(openDatabaseRequest)
    {
        openDatabaseRequest.onsuccess = function(){ performOperation(openDatabaseRequest.result); };
        openDatabaseRequest.onerror = errorComplete;
    }

   /**
    * Performs a get or remove operation on items in an object store specified
    * in {@code optionsObj} that are keyed by Strings in {@code dataArray}. 

    * @param database       the IDBDatabase object containing the object store that this operation will target
    */
    function performOperation(database)
    {
        //Create the transaction that the get or remove operation is to take place in
        var transaction = database.transaction([optionsObj.objectStoreData.name], (isGet ? "readonly" : "readwrite"));
        transaction.onerror = errorComplete;

        //Get a handle to the target object store
        var targetSource = transaction.objectStore(optionsObj.objectStoreData.name);

        //If the use of a specific index of the target object store
        //is specified, then reassign targetSource to the index
        if(useIndex && optionsObj.objectStoreIndexDataArray.length > 0)	
        {
            var targetIndexName = optionsObj.objectStoreIndexDataArray[0].name;
            targetSource = targetSource.index(targetIndexName);
        }
        /////

        //Store the name of the target source member function which which will be used to 
        //perform the  storage sub-operation(s) in to a local variable for conveniece.
        //
        //Remove operations on indices are not supported directly; we must first conduct retrieval 
        //operations to procure the primary keys of the pertinent data items, using each primary key
        //to conduct a traditional (object store based) deletion removal operation
        var operationFuncName = ((isGet || useIndex) ? "get" : "delete");

        //Variable to store the request for the execution of a given 
        //sub-operation. This makes it accessible to advance()
        var operationRequest;
        

       /**
        * Advances the operation.
        */
        function advance()
        {
            if(++i >= dataCount)
            {
                if(optionsObj.closeConnection) database.close();
                
                if(isGet)   complete(i, keyValuePairsObj);
                else        complete(i);
            }
            else
                executeSubOperation();		//process the data item at i (which was just incremented in the 'if' clause)   		
        }
        
        
       /**
        * Handles the successful conclusion of a sub-storage operation. In the
        * case of a retrieval operation, a mapping in keyValuePairsObj is established
        * between the operation's target item and the item's primary key.
        */
        function handleOperationConsumation()
        {
            var value = operationRequest.result;

            if(!useIndex)   //if the operation's target source is an object store
            {
                if(isGet) keyValuePairsObj[dataArray[i]] = (value || null);                              
                advance();
            }
            else if(value !== undefined)    //if the operation's target store is an index, and there
            {                                   //is an item mapped to the currently processing index key

                //Create a request to retrieve the primary key of "value"
                var getKeyRequest = targetSource.getKey(dataArray[i]);
                
                //Specify a function to execute upon the successful 
                //retrieval of the pertinent item's primary key
                getKeyRequest.onsuccess = function(){

                    if(isGet)   
                    {                                 
                        keyValuePairsObj[getKeyRequest.result] = value; 
                        advance();
                    }
                    else    //original storage operation is removal
                    {
                        var deleteRequest = targetSource.objectStore["delete"](getKeyRequest.result);
                        deleteRequest.onsuccess = advance;
                    }
                }; 
                /////
            }
            else        //the operation's target store is an index, and there is no item mapped to the currently processing index key
                advance();
        }


       /**
        * Retrieves or removes the data item keyed by a String in 
        * {@code dataArray} from the target object store.
        */
        function executeSubOperation()
        {
            //Create a request to either retrieve or remove the item in the target object store 
            //keyed by the currently processing string in dataArray, and specify
            //handleOperationResult as the function to call upon success of the sub-operation
            operationRequest = targetSource[operationFuncName](dataArray[i]);
            operationRequest.onsuccess = handleOperationConsumation;
            /////
        }

        executeSubOperation();	//starts the get or remove operation
    }
    
    indexedDB_executeStorageOperation(optionsObj, handleOpenDatabaseRequest, errorComplete);
}



function indexedDB_get(dataArray, optionsObj, complete)
{
    indexedDB_getOrRemove("get", dataArray, optionsObj, complete);
}



function indexedDB_remove(dataArray, optionsObj, complete)
{
    indexedDB_getOrRemove("remove", dataArray, optionsObj, complete);
}
	
        
	
/**
* Determines whether a String is a representation a simple equality expression. Such an
* expression is defined as a a single expression with exactly one equality operator.

* @param exprStr        a String representation of an expression
* @return		true if {@code exprStr} is a single expression making use
                        of exactly one equality (== or ===) operator, false otherwise
*/
function isSimpleEqualityExpression(exprStr)
{
    var isSimpleEqualityExpr = false;

    //Redefine exprStr to be the string resulting from the 
    //removal of all of its contained string sequences
    exprStr = exprStr.replace(/(?:".*?")|(?:'.*?')/g, "");

    var logicalOpRegex = /(?:&&)|(?:\|\|)/;
    var hasLogicalOperator = logicalOpRegex.test(exprStr);

    if(!hasLogicalOperator)	//in other words, if exprStr represents a single expression
    {
        var equalityOpRegex = /[^=]===?[^=]/g;
        var equalityOpMatchCount = 0;

        //Iteratively search exprStr for substrings matching equalityOpRegex,
        //updating matchCount upon each successful match
        while(equalityOpRegex.exec(exprStr) !== null) equalityOpMatchCount++;
        isSimpleEqualityExpr = (equalityOpMatchCount === 1);
    }

    return isSimpleEqualityExpr;
}
	
	
        
/**
* Procures data from a String representing a simple equality expression that will be used
* start the unconditional equivalent of the operation that the expression is related to,
* provided it's determined the operation can be executed as an unconditional operation. A simple
* equality expression is defined as a single expression with exactly one equality operator.

* @param exprStr		a String representation of a simple equality expression
* @return			null if it is determined that the conditional operation related to
*                               {@code exprStr} cannot be conducted as an unconditional operation,  
*                               otherwise an object consisting of the following properties:
                                    - key: 		  the value resulting from the evaluation of the r-value side of {@code exprStr} 
                                    - originType: the type of database structure expected to index the non-global l-value of {@code exprStr} 
*/
function procureUnconditionalOperationImpetusData(exprStr)
{
    var impetusDataObj = null;

	//This regex will match a side of exprStr consisting of a single l-value
	//(the only l-value identifiers defined in the planned execution context of exprStr are 
	//global identifiers and the (application-reserved) "valueObj" and "keyObj" identifiers)
	var rValueComplementRegex = /(?:^\s*(?:(?:valueObj(?:(?:\s*\[(?:"|').+?(?:"|')\])|\s*\.[$\w]+)*)|keyObj)\s*===?)|(?:===?\s*(?:(?:valueObj(?:(?:\s*\[(?:"|').+?(?:"|')\])|\s*\.[$\w]+)*)|keyObj)\s*$)/;

	//This regex will match a side of exprStr that soley consists of the "keyObj" l-value
	var keyObjIncompleteEqualityRegex = /(?:===?\s*keyObj)|(?:keyObj\s*===?)/;

	var matchDataObj;
	if((matchDataObj = rValueComplementRegex.exec(exprStr)) != null)	//if there is a side of exprStr consisting of a single l-value
	{
		//Reassign exprStr to the unmatched part of exprStr; this will be a single
		//side of its represented expression which should yields a value when evaluated
		exprStr = matchDataObj.index === 0 
						? exprStr.substring(matchDataObj[0].length)
						: exprStr.substring(0, matchDataObj.index);
							
		//Evaluate exprStr to yield the result of its represented expression (since the arugment of eval is assumed to
		//be Javascript source code, we escape  the backslashes in exprStr beforehand to transform it in to its source
		//code representation). If exprStr contains non-global l-values, an exception will be thrown during evaluation
		var key = eval(escapeBackslashes(exprStr));

		//Determine the type of database structure expected to index to the matched l-value
		var originType = (keyObjIncompleteEqualityRegex.test(matchDataObj[0]) ? "objectStore" : "index"); 

		impetusDataObj = {key: key, originType: originType};
	}

	return impetusDataObj;
}

	
	
/**
* Conducts an indexedDB get or remove operation on records in a specified 
* object store which meet criteria specified in a supplied expression. 
*
* This function forwards execution to its unconditional equivalent provided the supplied 
* expression is a simple equality expression with one side consisting of a reference to a
* record's key or one of its properties (the latter also requiring the property's index
* to be specified), and the other consisting of r-values and/or global l-values.

* @param operationType      a String denoting the to-be-conducted type of storage operation 
* @param exprStr            a String representation of a Javascript boolean expression
* @param optionsObj         an object containing auxiliary data pertinent to the to-be-conducted storage operation
* @param complete           a function capable of progressing the execution of the set of related storage operations this operation belongs to
*/
function indexedDB_getOrRemoveAll(operationType, exprStr, optionsObj, complete)
{
    var isGet = (operationType === "get");
    var removeExpirationData = optionsObj.removeExpirationData;
    var returnsData = (isGet || removeExpirationData);

    var i = 0;
    var dataArray =  (returnsData ? [] : undefined);

    //Create a function that will be used to advance the set of operations  
    //that this operation belongs to in the event of its failure
    var errorComplete = (returnsData ? createErrorCompleteFunction(complete, [0, []])
                                     : createErrorCompleteFunction(complete, [0]));

   /**
    * Wraps {@code complete} with a function that derives the arguments to
    * call it with from arguments that are supplied to the complete 
    * function of a non-conditional get/remove operation.
    */
    function wrapComplete()
    {
        var originalCompleteFunc = complete;

        complete = function(i, keyValuePairsObj){
            
            //Restore the original progression function
            complete = originalCompleteFunc;	

            //Call the (restored) progression function, supplying it with arguments derived 
            //from the wrapper function's received arguments. Note that the set of circumstances   
            //necessary for this function to be invoked guarentee keyValuePairsObj contains 
            //zero or one key-value pairs (indicative of the fruitfullness of the operation)
            var isFruitful = false;
            for(var key in keyValuePairsObj)
            {
                isFruitful = true;
                complete(i, [{key: key, value: keyValuePairsObj[key]}]);
            }
                
             if(!isFruitful)     complete(i, []);
        }
    }

    /**
    * Assigns functions to handle the various events that may fire during the
    * handling of a request to open a database for a conditional get or remove operation.

    * @param openDatabaseRequest		an IDBOpenDBRequest 
    */
    function handleOpenDabaseRequest(openDatabaseRequest)
    {
        openDatabaseRequest.onsuccess = function(){ performOperation(openDatabaseRequest.result);}
        openDatabaseRequest.onerror = errorComplete;
    }

   /**
    * Carries out a conditional get or remove operation on items in the object store specified
    * in {@code optionsObj}, that meet criterea specified in {@code exprStr}.

    * @param database		the IDBDatabase object containing the object store that this operation will target
    */
    function performOperation(database)
    {
        //Create the transaction that the get or remove operation is to take place in
        var transaction = database.transaction([optionsObj.objectStoreData.name], (isGet ? "readonly" : "readwrite"));
        transaction.onerror = errorComplete;

        //Get a handle to the target object store
        var targetObjectStore = transaction.objectStore(optionsObj.objectStoreData.name);

        //Store the presence of a key path in a local variable for use in determining how,
        //if the operation yields data, that data will be inserted in to dataArray 
        var hasKeyPath = (targetObjectStore.keyPath !== null);
        
        //Determine if targetObjectStore is to be cleared by the to-be-performed operation
        var isClearOperation = (!isGet && (exprStr === "true"));
        
        if(!isClearOperation)
        {
            //Create a request to open a cursor on the target object store
            var openCursorRequest = targetObjectStore.openCursor();

            //Designate an anonymous function to execute upon the success of a cursor iteration 
            //(which occurs automatically once one is opened). The function performs the specified
            //storage operation on the currently processing record if evaluation of exprStr returns true.
            openCursorRequest.onsuccess = function(){
                var cursor = openCursorRequest.result;
                var canContinue = true;

                if(cursor)	//if there is a record to be processed
                {
                    //Put the key and value objects of the current record in to local variables
                    //with reserved identifiers. If the identifiers appear in exprStr, the
                    //corresponding objects will be utilized in place of them during its evaluation
                    var keyObj = cursor.key;
                    var valueObj = cursor.value;
                    /////

                    if(eval(escapeBackslashes(exprStr)) === true)				//Since the arugment of eval is assumed to be Javascript source code, we escape the backslashes in 
					{																//exprStr, transforming it in to its source code representation, before feeding it to the function 
                        if(isGet)
                        {
                            var resultObj = (hasKeyPath ? valueObj : {key: keyObj, value: valueObj});
                            dataArray.push(resultObj);
                            ++i;
                        }
                        else	//delete
                        {
                            canContinue = false;		//Prevent the cursor from automatically iterating to the next record after this clause is exited

                            //Create a request for the deletion of the currently processing record, and assign an anonymous
                            //function to execute upon success of the operation which progresses the cursor to the next record
                            var dataItemDeleteRequest = cursor["delete"]();
                            dataItemDeleteRequest.onsuccess = function(){
                                    ++i; 
                                    if(dataArray) dataArray.push(keyObj);
                                    cursor["continue"]();
                            }
                            /////
                        }
                    }

                    //Iterate to the next record in the cursor's iteration direction.
                    //This action uses the same request (and thus this same success handler)
                    if(canContinue) cursor["continue"]();
                }
                else
                {
                    if(optionsObj.closeConnection) database.close();
                    
                    if(returnsData) complete(i, dataArray);
                    else            complete(i);
                }     
            }
        }
        else
        {
            //Create a request for the clearance of the target object store, and assign an 
            //anonymous function to execute upon success of the operation which concludes it
            var clearObjectStoreRequest = targetObjectStore.clear();
            clearObjectStoreRequest.onsuccess = function(){complete(0);};
            /////
        } 
    }


    var wasExecutionForwarded = false;

    if(isSimpleEqualityExpression(exprStr))
    {
        //Procure data which will be used to start the execution of this storage operation's unconditional
        //equivalent if it is determined that it can, and will be more efficient to be conducted that way.
        //If such a determination cannot be made, the result of this expression is null.
        var procuredProcessingDataObj = procureUnconditionalOperationImpetusData(exprStr); 

        //If the operation can be conducted as its unconditional equivalent, and its target storage structure
        //is an object store or specified index, then do so after wrapping the complete() function inside a
        //function that can supply it arguments in the form it accepts from the unconditional operation 
        if(procuredProcessingDataObj && (procuredProcessingDataObj.originType === "objectStore" || (optionsObj.objectStoreIndexDataArray.length > 0 && optionsObj.objectStoreIndexDataArray[0].unique)))
        {
            if(operationType === "get") wrapComplete();
            indexedDB_getOrRemove(operationType, [procuredProcessingDataObj.key], optionsObj, complete, (procuredProcessingDataObj.originType === "index"));
            wasExecutionForwarded = true;
        }
        /////
    }

    if(!wasExecutionForwarded)
        indexedDB_executeStorageOperation(optionsObj, handleOpenDabaseRequest, errorComplete);
}
	
	
	
function indexedDB_getAll(exprStr, optionsObj, complete)
{
    indexedDB_getOrRemoveAll("get", exprStr, optionsObj, complete);
}



function indexedDB_removeAll(exprStr, optionsObj, complete)
{
    indexedDB_getOrRemoveAll("remove", exprStr, optionsObj, complete);
}
	
	
	
/***************************************Test functions****************************************/
	
	
var testNum = Math.random() * Number.MAX_VALUE;
var testNumObj = new Number(Math.random() * Number.MAX_VALUE);

var testStr = "()<>@,;:\\<>/[]?={}";
var testDateObj = new Date();

var testObj = {num: testNum, numObj: testNumObj, str: testStr, dateObj: testDateObj};
var testArr = [testNum, testNumObj, testStr, testDateObj, testObj];

var objArray = [testNum, testNumObj, testStr, testDateObj, testObj, testArr];
var objCount = objArray.length;


var optionsObj = {
    databaseName: "Baked_Goods",
    databaseVersion: 1,
    objectStoreData: {name: "Main", keyPath: null, autoIncrement: false},
    objectStoreIndexDataArray: [],
    closeConnection: true
};
	
	
function clear()
{
    var indexedDB = (window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB);
    if(indexedDB) indexedDB.deleteDatabase(optionsObj.databaseName);
}
//clear();
	
	
	
/*
//indexedDB_executeStorageOperation test runner
(function(){


    var testFunc = function(assert){

        var mockOpenDatabaseRequestHandlerFunc = function(openDatabaseRequest){

            assert.ok("onblocked" in openDatabaseRequest);
            assert.ok("onupgradeneeded" in openDatabaseRequest);
            assert.ok("result" in openDatabaseRequest);
            assert.ok("error" in openDatabaseRequest);
            assert.ok("source" in openDatabaseRequest);
            assert.ok("transaction" in openDatabaseRequest);
            assert.ok("readyState" in openDatabaseRequest);
            assert.ok("onsuccess" in openDatabaseRequest);
            assert.ok("onerror" in openDatabaseRequest);
			
			clear();
        }

        var accessFailFunc = function(){assert.ok(false, "Error accessing database")};

        indexedDB_executeStorageOperation(optionsObj, mockOpenDatabaseRequestHandlerFunc, accessFailFunc);
    }

    QUnit.test("indexedDB_executeStorageOperation", testFunc);
})()
*/
	
/*
//handleOpenDatabaseRequestExt test runner
(function(){
    var objectStoreDataObjArray = [
        {name: "1", keyPath: null, autoIncrement: false},
        {name: "2", keyPath: null, autoIncrement: true},
        {name: "3", keyPath: "path.key", autoIncrement: true},
        {name: "4", keyPath: ["path1", "path2"], autoIncrement: false}
    ]

    var indexDataObjArray = [
        {name: "1", keyPath: null, unique: false, multiEntry: false},
        {name: "2", keyPath: "path.indexKey", unique: false, multiEntry: true},
        {name: "3", keyPath: ["path", "indexKey"], unique: true, multiEntry: false},
    ]

    var currentOptionsObj = {
        databaseName: "Baked_Goods",
        databaseVersion: 1,
        objectStoreIndexDataArray: indexDataObjArray
    }

    for(var i = 0; i < objectStoreDataObjArray.length; i++)
    {
        var testFunc = (function(pivotIndex){

            return function(assert){
                
                var currentObjectStoreDataObj = objectStoreDataObjArray[pivotIndex];
                var currentObjectStoreName = objectStoreDataObjArray[pivotIndex].name;

                currentOptionsObj.objectStoreData = currentObjectStoreDataObj;
                currentOptionsObj.databaseVersion = pivotIndex + 1; //version must be greater than 0

                var testCompleteFunc = function(){
                    
                    if((pivotIndex + 1) === objectStoreDataObjArray.length)
                        clear();

                    QUnit.start();
                }

                var accessFailFunc = function(){
                    assert.ok(false, "Error accessing or modifying database");
                    clear();
                };

                var successFunc = function(database){
                    var objectStoreNamesList = database.objectStoreNames;
                    assert.ok(objectStoreNamesList.contains(currentObjectStoreName));

                    var transaction = database.transaction([currentObjectStoreName], "readonly");
                    var pertinentObjectStore = transaction.objectStore(currentObjectStoreName);
                    var indexNamesList = pertinentObjectStore.indexNames;

                    for(var i = 0; i < indexDataObjArray.length; i++)
                        assert.ok(indexNamesList.contains(indexDataObjArray[i].name));
                    
                    database.close();
                    testCompleteFunc();
                }

                var handleOpenDatabaseRequestClosureFunc = function(openDatabaseRequest){
                    handleOpenDatabaseRequestExt(openDatabaseRequest, currentOptionsObj, successFunc, accessFailFunc);
                }

                indexedDB_executeStorageOperation(currentOptionsObj, handleOpenDatabaseRequestClosureFunc, accessFailFunc);
            }
        })(i)
        
        QUnit.asyncTest("handleOpenDatabaseRequest", testFunc);
    }
})()
*/
	
/*
//indexedDB_set test runner
(function(){

    var testFunc = function(assert){

        var setDataObjArray = [];
        for(var i = 0; i < objArray.length; i++)
            setDataObjArray.push({key: i, value: objArray[i]});

        var accessFailFunc = function(){assert.ok(false); QUnit.start("Error accessing database");}

        var testCompleteFunc = function(){
            clear();
            QUnit.start();
        }

        var setCheckFunc = function(){ 

            var checkSet = function(openDatabaseRequest){

                openDatabaseRequest.onsuccess = function(){
                    var processingIndex = 0;
                    
                    var objectStoreName = optionsObj.objectStoreData.name;
                
                    var database = openDatabaseRequest.result;
                    var transaction = database.transaction([objectStoreName], "readonly");
                    var targetObjectStore = transaction.objectStore(objectStoreName);

                    var advance = function(){
                        if(++processingIndex >= objArray.length)
                        {
                            database.close();
                            testCompleteFunc();
                        }       
                        else
                            executeCheckSet();
                    }

                    var executeCheckSet = function(){

                        var currentTestDataObj = setDataObjArray[processingIndex];
                        var getRequest = targetObjectStore.get(currentTestDataObj.key);

                        getRequest.onsuccess = function(){
                            assert.strictEqual(getRequest.result + "", currentTestDataObj.value + "");
                            advance();
                        }

                        getRequest.onerror = advance;
                    }
                    
                    executeCheckSet();
                }

                openDatabaseRequest.onerror = accessFailFunc;
            }

            indexedDB_executeStorageOperation(optionsObj, checkSet, accessFailFunc);
        }

        indexedDB_set(setDataObjArray, optionsObj, setCheckFunc);
    }

    QUnit.asyncTest("indexedDB_set", testFunc);
})()
*/
	
//This function primes the storage facility for the get, remove, get_all,
//and remove_all isf tests runners; as such, this function must be visible 
//(i.e uncommented) at the time any of those tests are to be run
function setupGetOrRemoveTest(openDatabaseRequest, successFunc, accessFailFunc, testSpecificOptionsObj){
    
    var localOptionsObj = (testSpecificOptionsObj ? testSpecificOptionsObj : optionsObj);
    
    openDatabaseRequest.onupgradeneeded = function(){
        
        var database = openDatabaseRequest.result
        
        var objectStoreData = localOptionsObj.objectStoreData;
        var targetObjectStore = database.createObjectStore(objectStoreData.name, objectStoreData.keyPath, objectStoreData);
        
        var objectStoreIndexDataArray = localOptionsObj.objectStoreIndexDataArray;
        
        if(objectStoreIndexDataArray)
        {
            var indexCount = objectStoreIndexDataArray.length;
            for(var i = 0; i < indexCount; i++)
            {
                var currentIndexDataObj = objectStoreIndexDataArray[i];
                targetObjectStore.createIndex(currentIndexDataObj.name, currentIndexDataObj.keyPath, currentIndexDataObj);
            }
        }
    }
    
    openDatabaseRequest.onsuccess = function(){
        var database = openDatabaseRequest.result;

        var objectStoreName = localOptionsObj.objectStoreData.name;
        var transaction = database.transaction([objectStoreName], "readwrite");
        var objectStore = transaction.objectStore(objectStoreName);

        var processingIndex = 0;

        function setDataItem(){
            var currentTestDataObj = objArray[processingIndex];
            var setRequest = objectStore.put(currentTestDataObj, processingIndex);

            setRequest.onsuccess = (++processingIndex < objArray.length ? setDataItem : (function(){database.close(); successFunc();})());
            setRequest.onError = successFunc;
        }

        setDataItem();
    }

    openDatabaseRequest.onerror = accessFailFunc;
}

	
/*
//This test runner makes use of data in the storage facility that
//is created by setupGetOrRemoveTest, and as such requires the 
//function (i.e uncommented) in order to function as expected
//
//indexedDB_get test runner
(function(){

    var testFunc = function(assert){
        var testCompleteFunc = function(){
            clear();
            QUnit.start();
        }

        var accessFailFunc = function(){assert.ok(false, "Error accessing database");}
        var getFunc = function(){

            var getCheck = function(processedItemCount, keyValuePairsObj){

                for(var key in keyValuePairsObj)
                    assert.equal(keyValuePairsObj[key] + "", objArray[key] + "");

                testCompleteFunc();
            }

            var keyArray = [];
            for(var i = 0; i < objArray.length; i++)
                    keyArray.push(i);

            indexedDB_get(keyArray, optionsObj, getCheck);
        }

        var setupWrapper = function(openDatabaseRequest){setupGetOrRemoveTest(openDatabaseRequest, getFunc, accessFailFunc);};
        indexedDB_executeStorageOperation(optionsObj, setupWrapper, accessFailFunc);
    }

    QUnit.asyncTest("indexedDB_get", testFunc);

})()
*/
	
	
/*
//This test runner makes use of data in the storage facility that
//is created by setupGetOrRemoveTest, and as such requires the 
//function (i.e uncommented) in order to function as expected
//
//indexedDB_remove test runner
(function(){

    var testFunc = function(assert){

        var testCompleteFunc = function(){
            clear();
            QUnit.start();
        }

        var failFunc = function(){assert.ok(false); testCompleteFunc();};
        var accessFailFunc = function(){assert.ok(false, "Error accessing database")};

        var removeFunc = function(){
            
            var keyArray = [];
            for(var i = 0; i < objArray.length; i++) keyArray.push(i);

            var removeCheck = function(processedItemCount){
                
                assert.strictEqual(processedItemCount, keyArray.length);

                var checkFunc = function(openDatabaseRequest){
                    
                    openDatabaseRequest.onsuccess = function(){
                        
                        var objectStoreName = optionsObj.objectStoreData.name;

                        var database = openDatabaseRequest.result;
                        var transaction = database.transaction([objectStoreName], "readonly");
                        var objectStore = transaction.objectStore(objectStoreName);

                        var processingIndex = 0;

                        var getItem = function(){
                            var currentKey = keyArray[processingIndex];
                            var getRequest = objectStore.get(currentKey);

                            getRequest.onsuccess = function(){
                                assert.strictEqual(getRequest.result, undefined);

                                if(++processingIndex >= keyArray.length)
                                {
                                    database.close();
                                    testCompleteFunc();
                                }
                                else
                                    getItem();
                            }

                            getRequest.onerror = failFunc;
                        }
                        
                        getItem();
                    }
                    
                    openDatabaseRequest.onerror = failFunc;
                }

                indexedDB_executeStorageOperation(optionsObj, checkFunc, accessFailFunc);
            }

            indexedDB_remove(keyArray, optionsObj, removeCheck);
        }

        var setupWrapper = function(openDatabaseRequest){setupGetOrRemoveTest(openDatabaseRequest, removeFunc, accessFailFunc);};
        indexedDB_executeStorageOperation(optionsObj, setupWrapper, accessFailFunc);
    }

    QUnit.asyncTest("indexedDB_remove", testFunc);
})()
*/
        
        
/*
//isSimpleEqualityExpression test runner
(function(){

    var isSimpleEqualityExpressionArgObjArray = [
        {argumentStr: "true == true", expectedResultBool: true},
        {argumentStr: "true===true", expectedResultBool: true},
        {argumentStr: "true==true && false === false", expectedResultBool: false},
        {argumentStr: "false", expectedResultBool: false},
        {argumentStr: "false = false", expectedResultBool: false},
        {argumentStr: "==false", expectedResultBool: false},
        {argumentStr: "false===", expectedResultBool: false},
        {argumentStr: "\"These are == substrings ==\" with \'===equality === operators\'", expectedResultBool: false}
    ]

    var testFunc = function(assert){

        for(var i = 0; i < isSimpleEqualityExpressionArgObjArray.length; i++)
        {
            var currentArgObj = isSimpleEqualityExpressionArgObjArray[i];
            var actualResultBool = isSimpleEqualityExpression(currentArgObj.argumentStr);

            assert.strictEqual(actualResultBool, currentArgObj.expectedResultBool);
        }
    }

    QUnit.test("isSimpleEqualityExpression", testFunc);
})()
*/
	
/*
//procureUnconditionalOperationImpetusData test runner
(function(){
    var procureUnconditionalOperationImpetusArgObjArray = [
        {argumentStr: "keyObj[\"testProp\"] === 6", expectedResultDataObj: null},
        {argumentStr: "\"This is a nested string\" === keyObj.testProp ", expectedResultDataObj: null},
        {argumentStr: "keyObj == (2 * 2) + 2", expectedResultDataObj: {key: 6, originType: "objectStore"}},
        {argumentStr: "'valueObj.testProp' === 2", expectedResultDataObj: null},
        {argumentStr: "valueObj === 'This is a nested string'", expectedResultDataObj: {key: "This is a nested string", originType: "index"}},
        {argumentStr: "valueObj['testProp']['testProp1'] == new Date(0)", expectedResultDataObj: {key: new Date(0), originType: "index"}},
        {argumentStr: "\"valueObj.testProp\" === valueObj.testProp1.testProp ", expectedResultDataObj: {key: "valueObj.testProp", originType: "index"}},
        {argumentStr: "[\"this\",\"is\",\"an\",\"array\"] === valueObj[\"testProp\"].testProp", expectedResultDataObj: {key: ["this","is","an","array"], originType: "index"}},
        {argumentStr: "  valueObj.testProp[\'testProp\'] == [\"this\",\"is\",\"an\",\"array\"] ", expectedResultDataObj: {key: ["this","is","an","array"], originType: "index"}}
    ]


    var testFunc = function(assert){

        for(var i = 0; i < procureUnconditionalOperationImpetusArgObjArray.length; i++)
        {
            var currentArgObj = procureUnconditionalOperationImpetusArgObjArray[i];
            var actualResultDataObj = procureUnconditionalOperationImpetusData(currentArgObj.argumentStr);

            assert.deepEqual(actualResultDataObj, currentArgObj.expectedResultDataObj);
        }
    }

    QUnit.test("procureUnconditionalOperationImpetusData", testFunc);
})()
*/
	
	
/*
//This test runner makes use of data in the storage facility that
//is created by setupGetOrRemoveTest, and as such requires the 
//function (i.e uncommented) in order to function as expected
//
//indexedDB_getAll test runner
(function(){

    var testSpecificOptionsObj = {
        databaseName: "Baked_Goods",
        databaseVersion: 1,
        objectStoreData: {name: "Main", keyPath: null, autoIncrement: false},
        objectStoreIndexDataArray: [{name: "Index1", keyPath: "", unique: true, multiEntry: false}],
        closeConnection: true
    }

    var filterDataObjArray = [
        {filterStr: "true", expectedDataItem: [{key:0, value: objArray[0]}, {key:1, value: objArray[1]}, {key:2, value: objArray[2]}, {key:3, value: objArray[3]},{key:4, value: objArray[4]}, {key: 5, value: objArray[5]}]},
        {filterStr:"typeof valueObj === \"number\" && valueObj === " + objArray[0], expectedDataItem: {key: 0, value: objArray[0]},  expectedDataItemCount: 1},
        {filterStr: "valueObj == '" + objArray[2] + "'", expectedDataItem: {key: 2, value: objArray[2]}, expectedDataItemCount: 1}
    ]

    var pivotIndex = 0;
    var filterDataObj;

    var testFunc = function(assert){

        var testCompleteFunc = function(){
            if(++pivotIndex >= filterDataObjArray.length)
            {
                clear();
                QUnit.start();
            }
            else
                getAllFunc();
        }
        
        var failFunc = function(){assert.ok(false); testCompleteFunc();};
        var accessFailFunc = function(){assert.ok(false, "Error accessing database")};

        var getAllCheckFunc = function(processedItemCount, dataObjArray){

            if(filterDataObj.filterStr !== "true")
            {
                if(dataObjArray.length > 0)
                {   
                    assert.equal(dataObjArray[0].key + "", filterDataObj.expectedDataItem.key + "");
                    assert.equal(dataObjArray[0].value + "", filterDataObj.expectedDataItem.value + "");
                }
                else
                    assert.ok(false); 
            }
            else
                 assert.deepEqual(dataObjArray + "", filterDataObj.expectedDataItem + "");
                
            testCompleteFunc();
        }

        var getAllFunc = function(){
            filterDataObj = filterDataObjArray[pivotIndex];
            indexedDB_getAll(filterDataObj.filterStr, testSpecificOptionsObj, getAllCheckFunc);
        }
        
        var setupWrapper = function(openDatabaseRequest){ setupGetOrRemoveTest(openDatabaseRequest, getAllFunc, accessFailFunc, testSpecificOptionsObj);};
        indexedDB_executeStorageOperation(testSpecificOptionsObj, setupWrapper, accessFailFunc);
    }

    QUnit.asyncTest("indexedDB_getAll", testFunc);
})()
*/


//This test runner makes use of data in the storage facility that
//is created by setupGetOrRemoveTest, and as such requires the 
//function (i.e uncommented) in order to function as expected
//
//indexedDB_removeAll test runner
(function(){
    
    var testSpecificOptionsObj = {
        databaseName: "Baked_Goods",
        databaseVersion: 1,
        objectStoreData: {name: "Main", keyPath: null, autoIncrement: false},
        objectStoreIndexDataArray: [{name: "Index1", keyPath: "", unique: true, multiEntry: false}],
        closeConnection: true
    }

    var filterDataObjArray = [
        {filterStr:"valueObj instanceof Number && valueObj == " + objArray[1], targetDataItemKey: 1},
        {filterStr: "valueObj === " + objArray[0], targetDataItemKey: 1},
        {filterStr: "true"}
    ]

    var pivotIndex = 0;
    var filterDataObj;

    var testFunc = function(assert){

        var testCompleteFunc = function(){
            if(++pivotIndex === filterDataObjArray.length)
            {
                clear();
                QUnit.start();
            }
            else
                removeAllFunc();
        }

        var accessFailFunc = function(){assert.ok(false); testCompleteFunc();}

        var removeAllCheckFunc = function(processedItemCount, dataObjArray){

            var checkFunc = function(openDatabaseRequest){
                
                openDatabaseRequest.onsuccess = function(){
                    
                    var objectStoreName = optionsObj.objectStoreData.name;

                    var database = openDatabaseRequest.result;
                    var transaction = database.transaction([objectStoreName], "readonly");
                    var objectStore = transaction.objectStore(objectStoreName);

                    if(!filterDataObj.hasOwnProperty("targetDataItemKey"))
                    {
                        var countRequest = objectStore.count();

                        countRequest.onsuccess = function(){
                            assert.strictEqual(countRequest.result, 0);
                            testCompleteFunc();
                        }

                        countRequest.onerror = function(){assert.ok(false); testCompleteFunc();}
                    }
                    else
                    {
                        var getRequest = objectStore.get(filterDataObj.targetDataItemKey);

                        getRequest.onsuccess = function(){
                                assert.strictEqual(getRequest.result, undefined);					
                                testCompleteFunc();
                        }

                        getRequest.onerror = function(){assert.ok(false); testCompleteFunc();}
                    }
                }
                
                openDatabaseRequest.onerror = accessFailFunc;
            }

            indexedDB_executeStorageOperation(testSpecificOptionsObj, checkFunc, accessFailFunc);
        }

        var removeAllFunc = function(){
            filterDataObj = filterDataObjArray[pivotIndex];
            indexedDB_removeAll(filterDataObj.filterStr, testSpecificOptionsObj, removeAllCheckFunc);
        }
        
        var setupWrapper = function(openDatabaseRequest){setupGetOrRemoveTest(openDatabaseRequest, removeAllFunc, accessFailFunc, testSpecificOptionsObj);};
        indexedDB_executeStorageOperation(testSpecificOptionsObj, setupWrapper, accessFailFunc);
        
    }

    QUnit.asyncTest("indexedDB_removeAll", testFunc);
})()



